//*****************************************************************************
//
// Имя файла    : 'ta.cpp'
// Заголовок    : Драйвер модуля Timer A (TA)
// Автор        : Барышников Р. А.
// Контакты     : plexus_bra@rambler.ru
// Дата         : 03/06/2012
//
// Описание:
// Источником тактирования таймера является SMCLK.
// При использовании вненего кварцевого резонатоа, нужно настроить ACLK и
// изменить источник тактирования для Таймера A на TASSEL_1.
//
//*****************************************************************************

#include "core\ta.h"
#include "core\core.h"
#include "core\clock.h"

// ============================================================================
//                          Глобальные переменные
// ============================================================================
    
    CTimerA  ta;

// ============================================================================
///
///                            Конструктор
///
// ============================================================================

CTimerA::CTimerA()
{
}

// ============================================================================
///
///         Поиск лучшего делителя MCK для указанной частоты таймера
///
// ============================================================================
/// Результат будет удовлетворять условию:
///
///   (MCK / (DIV * 65536)) <= freq <= (MCK / DIV)
///
/// с делителем DIV максимально возможным
// ============================================================================
/// \param  freq     Желаемая частота таймера
/// \param  mck      Частота MCK
/// \param  tcclks   Значение поля TCCLKS
/// \param  counter  Значение счетчика 
/// \return 1 если делитель найден; иначе 0
// ============================================================================

void CTimerA::FindMckDivisor (uint freq, uint32 mck, uint* div, uint* counter)
{
    uint index = 0;
    uint divisors[4] = {1, 2, 4, 8};
    
    // Поиск делителя
    while ((uint32)freq <= (uint32)((mck / divisors[index]) / 65536) && (++index < 4));
    
    // Сохранение результатов
    if (index < 4)    
    {
        *div  = index;
        *counter = (mck / divisors[index]) / freq;
    }
    else
    {
        // Невозможно установить требуемую частоту таймера при выбранной MCK
        while(1);
    }
}

// ============================================================================
///
///                          Конфигурация таймера
///
// ============================================================================
/// \param  freq      Частота таймера
/// \param  handler   Фукнция-обработчик прерывания
/// \param  priority  Приоритет прерываний таймера
/// \param  param     Дополнительные флаги регистра TC_CMR
// ============================================================================

void CTimerA::Configure (uint freq,/* THandlerISR* handler,*/ uint param)
{
    uint div;
    uint counter;
    // Настройка таймера на выбранную частоту
    FindMckDivisor(freq, MckClock, &div, &counter);
    // Настройка режима работы (Источник тактирования - SMCLK)
    // Добавление переданных параметров
    // Остановка таймера (режим "Стоп", установка MCx = 00h)
    TACTL = (div << 5) | MC_0 | TASSEL_2 | param;  
    TACCR0 = counter;
    
    // Разрешение прерываний (в записимости от функции)
    //if (handler) 
    //{
        #warning Заглушка
        //configure_aic(m_Id, priority, AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL, handler);
        //enable_aic(m_Id); 
    //}
}

// ============================================================================
///
///                       Деинициализация таймера
///
// ============================================================================

void CTimerA::UnInit (void)
{
    // Остановка таймера
    Stop();    
    //// Запрет прерываний 
    //disable_aic(m_Id);
}

// ============================================================================
///
///                            Запуск таймера
///
// ============================================================================

void CTimerA::Start (void)
{
    // Запуск таймера в режиме "Вверх" до TACCR0, разрешение прерываний
    TACTL |= MC_1;  // | TAIE;
    TACCTL0 = CCIE;
}

// ============================================================================
///
///                            Остановка таймера
///
// ============================================================================

void CTimerA::Stop (void)
{
    // Остановка таймера
    TACTL |= MC_0;
    // Запрет прерываний
    TACCTL0 &= ~CCIE;
    //TACTL &= ~TAIE;
}

#warning Прочитать TACCTL (Захват)

// ============================================================================
///
///                          Перезапуск таймера
///
// ============================================================================

void CTimerA::Restart (void)
{

}

// ============================================================================
///
///                        Разрешение прерываний
///
// ============================================================================

void CTimerA::EnableIrq (void)
{
    TACCTL0 = CCIE;
}

// ============================================================================
///
///                          Запрет прерываний
///
// ============================================================================

void CTimerA::DisableIrq (void)
{
    TACCTL0 &= ~CCIE;
}