//*****************************************************************************
//
// Имя файла    : 'i2c.cpp'
// Заголовок    : Драйвер последовательной шины данных I2C
// Автор        : Барышников Р. А.
// Контакты     : plexus_bra@rambler.ru
// Дата         : 17.10.2012
//
//*****************************************************************************

#include "core\i2c.h"
#include "core\pio.h"

// =============================================================================
//                                 Отладка
// =============================================================================

// =============================================================================
//                                Костанты
// =============================================================================

// =============================================================================
//                                 Макросы
// =============================================================================

// =============================================================================
//                           Глобальные переменные
// =============================================================================
    
    // Линия данных
    uint16 g_SDA;
    // Линия тактирования
    uint16 g_SCL;

// =============================================================================
//                             Прототипы функций
// =============================================================================

// ============================================================================
///    
///                           Инициализация I2C
///
// ============================================================================
/// \param  sda  линия данных
/// \param  scl  линия тактирования
// ============================================================================

void InitI2C (uint16 sda, uint16 scl)
{
    // Инициализация глобальных переменных
    g_SDA = sda;
    g_SCL = scl;
    
    // Настройка выводов линий тактирования и данных
    cfg_pin(g_SDA, PIN_OUTPUT);
    cfg_pin(g_SCL, PIN_OUTPUT);
    
    // Начальная установка в 1
    set_pin(g_SDA);
    set_pin(g_SCL);
}

// ============================================================================
///    
///                            Начало передачи
///
// ============================================================================

void StartI2C (void)
{
    clr_pin(g_SDA);
    for (uint i = 0; i < I2C_WAIT; i++)
    {
      // задержка
    }
}

// ============================================================================
///    
///                            Конец передачи
///
// ============================================================================

void StopI2C (void)
{
    for (uint i = 0; i < I2C_WAIT; i++);
    set_pin(g_SCL);
    for (uint i = 0; i < I2C_WAIT; i++);
    set_pin(g_SDA);
}

// ============================================================================
///    
///                 Запись байта
///
// ============================================================================
/// \param   value  значение байта
/// \return         тип подтверждения
// ============================================================================

ETypeACK WriteByteI2C (uchar value)
{   
    for(uchar i = 0; i < 8; i++)
    {
        clr_pin(g_SCL);
        
        for (uint i = 0; i < I2C_WAIT; i++);
        
        if ((value & 0x80) == 0)
        {
            set_pin(g_SDA, 0);
        }
        else
        {
            set_pin(g_SDA, 1);
        }
        set_pin(g_SCL);
        value = value << 1;
        
        for (uint i = 0; i < I2C_WAIT; i++);
    }
 
    #ifdef WITH_ACK
        // Посылаем бит ACK
        clr_pin(g_SCL);
        cfg_pin(g_SDA, PIN_INPUT_DRIVE);    
        
        for (uint i = 0; i < I2C_WAIT; i++);
        
        set_pin(g_SCL);
        
        // Проверка ответа ACK
        for (uint i = 0; i < I2C_WAIT; i++);
        if ((P1IN & g_SDA) == 0)
        {   
             clr_pin(g_SCL);
             cfg_pin(g_SDA, PIN_OUTPUT);
             return I2C_ACK;
        }
        else
        {
            clr_pin(g_SCL);
            cfg_pin(g_SDA, PIN_OUTPUT);
            return I2C_NACK;
        }
    #else
        return I2C_WITHOUT_ACK;
    #endif // #ifdef WITH_ACK
}

// ============================================================================
///    
///                               Чтение байта
///
// ============================================================================
/// \return  value  принятый байт
// ============================================================================

uchar ReadByteI2C (void)
{
    uchar value;
    
    cfg_pin(g_SDA, PIN_INPUT_DRIVE);
    for(uchar i = 0; i < 8; i++, value <<= 1)
    {
        clr_pin(g_SCL);
        
        for (uint i = 0; i < I2C_WAIT; i++);
        
        if ((P1IN & g_SDA) == 0)
        {
            value |= 0;
        }
        else
        {
            value |= 1;
        }
        set_pin(g_SCL);
        
        for (uint i = 0; i < I2C_WAIT; i++);
    }
    cfg_pin(g_SDA, PIN_OUTPUT);
    
    // Посылаем ответ NACK
    clr_pin(g_SCL);
    set_pin(g_SDA);
    for (uint i = 0; i < I2C_WAIT; i++);
    set_pin(g_SCL);
    for (uint i = 0; i < I2C_WAIT; i++);
    clr_pin(g_SCL);
    
    return value;
}